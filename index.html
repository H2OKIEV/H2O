<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Viewer</title>
    <style>
        #3d-viewer {
            cursor: grab;
            position: absolute;
            z-index: 99;
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
            /* Отключаем стандартное поведение касания */
            -webkit-tap-highlight-color: transparent;
            /* Убирает синий эффект */
            outline: none;
        }

        #3d-viewer canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
            user-select: none;
            /* Отключаем выделение */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -khtml-user-select: none;
            -webkit-touch-callout: none;
            /* Отключаем вызовы в Android и iOS */
        }

        /* .cursor-pointer {
            cursor: pointer;
        }

        .cursor-clicking {
            cursor: grabbing;
        }*/
    </style>
</head>

<body>
    <div id="3d-viewer" style="width: 100%; height: 97vh;"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/environments/RoomEnvironment.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/EXRLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/threejs-utils@0.1.3/lib/stats.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="js/controls.js"></script>
    <script src="js/controlstouch.js"></script>
    <script src="js/controlskeyboard.js"></script>
    <script src="js/debug.js"></script>
    
    <script >

        var scene = new THREE.Scene();

        var container = document.getElementById('3d-viewer');
        var renderWidth = container.clientWidth;
        var renderHeight = container.clientHeight;

        var camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 200);
        var cameraHeight = 1.5;
        camera.position.set(1, cameraHeight, 1);
        camera.lookAt(3, cameraHeight, 1);




        scene.add(camera);

        var renderer = new THREE.WebGLRenderer({ antialias: true, /*preserveDrawingBuffer: true/*, alpha: true*/ });
        renderer.setSize(renderWidth, renderHeight);
        renderer.setPixelRatio(1);
        renderer.domElement.style.width = '100%';
        renderer.domElement.style.height = '100%';
        renderer.domElement.style.imageRendering = 'auto';
        container.appendChild(renderer.domElement);

        var size = new THREE.Vector2();
        renderer.getSize(size);
        console.log('devicePixelRatio:', window.devicePixelRatio);
        console.log('Текущая ширина рендера:', size.width);
        console.log('Текущая высота рендера:', size.height);

        /* renderer.shadowMap.enabled = true; // Включаем карту теней
         renderer.shadowMap.type = THREE.BasicShadowMap; // Настройка типа теней (мягкие)*/
        // Установите начальное значение экспозиции
        // renderer.toneMapping = THREE.ReinhardToneMapping;

        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.8;
        //renderer.outputEncoding = THREE.sRGBEncoding;

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();
        const environment = new THREE.RoomEnvironment();
        var defaultEnvMap = pmremGenerator.fromScene(environment).texture;
        scene.environment = defaultEnvMap;

        var stats = new Stats();
        stats.showPanel(0); // 0 показывает FPS, 1 - время рендеринга, 2 - память
        document.body.appendChild(stats.dom);


        // Добавляем окружающий свет
        /*  const ambientLight = new THREE.AmbientLight(0xffffff, 1.3);
          scene.add(ambientLight); */



        var loader = new THREE.GLTFLoader();



        // Создаем камеру для карты (вид сверху)
        /*    const mapCamera = new THREE.OrthographicCamera(-5, 5, 5, -5, 0.1, 100);
            mapCamera.position.set(0, 2.5, 0); // Камера расположена высоко и смотрит вниз
            mapCamera.layers.enable(1);
            mapCamera.lookAt(0, 0, 0); // Смотрит на центр сцены
    
            // Создаем рендер для миникарты
            const mapRenderer = new THREE.WebGLRenderer({ }); // Используйте alpha, если хотите видеть прозрачный фон
            mapRenderer.setSize(250, 250); // Размер карты
            mapRenderer.domElement.style.position = 'absolute'; // Позиционирование миникарты
            mapRenderer.domElement.style.top = '10px'; // Расположение снизу
            mapRenderer.domElement.style.left = '10px'; // Расположение слева
            mapRenderer.domElement.style.pointerEvents = 'none'; // Отключаем взаимодействие с миникартой
            container.appendChild(mapRenderer.domElement); // Добавляем миникарту в контейнер
            */

        // Создаем материал для круга
        /* const circleMaterial1 = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // 
 
         // Создаем геометрию круга
         const circleGeometry1 = new THREE.CircleGeometry(0.2, 32); // Радиус 0.1, 32 сегмента
 
         // Создаем меш круга
         const circleMesh = new THREE.Mesh(circleGeometry1, circleMaterial1);
         circleMesh.position.set(camera.position.x, 0.1, camera.position.z); // Устанавливаем позицию на месте камеры
         circleMesh.rotation.x = -Math.PI / 2; // Поворачиваем круг, чтобы он был горизонтально
         circleMesh.layers.set(1);*/
        // Добавляем круг в сцену
        // scene.add(circleMesh);
        camera.layers.enableAll();

        // Функция для обновления положения маркера на карте
        function updateCameraMarker() {
            mapCamera.position.set(camera.position.x, 2.5, camera.position.z);
            circleMesh.position.set(camera.position.x, 0.1, camera.position.z);
        }


        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();

        var canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 256;
        var context = canvas.getContext('2d');
        context.fillStyle = 'rgba(255, 255, 255, 0)';
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.beginPath();
        context.arc(128, 128, 128, 0, Math.PI * 2);
        context.arc(128, 128, 110, 0, Math.PI * 2, true);
        context.closePath();
        context.fillStyle = 'rgba(255, 255, 255, 1)';
        context.fill();

        // Создание круга (должно выполняться один раз)
        const innerRadius = 0.08; // Внутренний радиус, который задает пустоту
        const outerRadius = 0.1;  // Внешний радиус
        const circleGeometry = new THREE.RingGeometry(innerRadius, outerRadius, 32); // Радиус 0.1
        const circleMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            side: THREE.DoubleSide,
            depthTest: false // Отключаем тестирование на глубину
        });
        const circle = new THREE.Mesh(circleGeometry, circleMaterial);
        // Устанавливаем высокий приоритет рендеринга для круга
        circle.renderOrder = 9999;
        scene.add(circle); // Добавляем круг на сцену

        var isMouseDown = false;
        var mouseX = 0;
        var mouseY = 0;
        var prevMouseX = 0;
        var prevMouseY = 0;
        var mouseDownTime = 0;
        var mouseMoved = false;
        var touchStartX = 0;
        var touchStartY = 0;






        let currentCameraQuaternion = camera.quaternion.clone();  // Текущее состояние кватерниона камеры

        // Начальная ориентация камеры
        var cameraRotation = new THREE.Euler().setFromQuaternion(camera.quaternion, 'XYZ');
        yaw = cameraRotation.y;
        pitch = cameraRotation.x;
        // Переменные для визуализации raycast
        let rayLine;
        const rayLineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 }); // Красный цвет для линии
        const rayLineGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),  // Начальная точка
            new THREE.Vector3(0, 0, 0)   // Конечная точка
        ]);

        /* const clickMarkerGeometry = new THREE.SphereGeometry(0.1, 32, 32); // Сфера диаметром 0.1
         const clickMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // Синий цвет
         let clickMarker = new THREE.Mesh(clickMarkerGeometry, clickMarkerMaterial);
         scene.add(clickMarker); // Добавляем в сцену*/

        // Создаем линию и добавляем ее в сцену
        rayLine = new THREE.Line(rayLineGeometry, rayLineMaterial);
        scene.add(rayLine);




        const bloomLayer = new THREE.Layers(); // Для блума
        function init() {

            const loader = new THREE.GLTFLoader();
            loader.load('flat_1C1.glb', // Путь к вашему файлу
                function (gltf) {
                    // Добавляем загруженную модель в сцену
                    scene.add(gltf.scene);
                    console.log('Модель успешно загружена:', gltf);

                    // Обрабатываем материалы модели
                    gltf.scene.traverse((node) => {
                        // console.log("Объект: ", node); // Имя объекта

                        if (node.isMesh && node.material) {
                            const material = node.material;
                            node.updateMatrixWorld(true);

                            const geometry = node.geometry;
                            if (geometry.attributes.uv1) {
                                console.log(`Объект ${node.name} содержит дополнительный UV-набор (uv1).`);
                            }

                            // Вычисляем границы объекта в мировых координатах
                            const boundingBox = new THREE.Box3().setFromObject(node);

                            // Создаем BoxHelper и корректируем его по мировым координатам
                            const boxHelper = new THREE.BoxHelper(node, 0x0000ff);
                            boxHelper.name = "boxHelper_" + node.name;

                            // Применяем матрицу трансформации объекта
                            boxHelper.position.copy(node.getWorldPosition(new THREE.Vector3())); // Переносим BoxHelper в мировую позицию
                            boxHelper.scale.copy(node.getWorldScale(new THREE.Vector3())); // Учитываем масштаб объекта
                            boxHelper.rotation.setFromRotationMatrix(node.matrixWorld); // Учитываем вращение объекта
                            boxHelper.visible = false;
                            // Добавляем BoxHelper в сцену
                            scene.add(boxHelper);

                            // console.log("Меш:", node);
                            // console.log("BoxHelper:", boxHelper);
                            // console.log("Границы в мировых координатах:", boundingBox.min, boundingBox.max);

                            // Проверяем, есть ли у материала карта эмиссии
                            /*  if (material.map) console.log('Base Color Map:', material.map);
                              if (material.normalMap) console.log('Normal Map:', material.normalMap);
                              if (material.metalnessMap) console.log('Metallic Map:', material.metalnessMap);
                              if (material.roughnessMap) console.log('Roughness Map:', material.roughnessMap);
                              if (material.emissiveMap) console.log('Emissive Map:', material.emissiveMap);*/

                            // Если объект с именем "Cube", то добавляем точечный свет
                            if (node.name === "Hall_lamp1") {
                                material.emissiveIntensity = 1;
                                //cube = node; // Сохраняем ссылку на куб для дальнейшей работы с ним
                                node.layers.enable(bloomLayer); // Включаем слой для блума
                                material.emissiveIntensity = 1;
                                console.log('Интенсивность эмиссии для Cube установлена в 20');
                            }

                            if (material.emissiveMap) {
                                console.log('Интенсивность эмиссии:', material.emissiveIntensity, node.name);

                                if (node.material) { // Проверяем, есть ли материал у объекта

                                    console.log("Материал: ", node.material.name); // Название материала
                                }
                                // Логируем цвет эмиссии
                                console.log('Цвет эмиссии:', material.emissive.getHexString());

                            }
                        }
                    });

                    // Устанавливаем блум для куба
                    /*  if (cube) {
                          addBloomEffect(cube);
                      }*/

                    // Настроим эффект композиции
                    // setupPostProcessing();

                    countTriangles(scene);
                    //visualizeBoundingBoxes(scene);
                    console.log("Все дочерние элементы сцены после :", scene.children);
                },
                undefined, // Опциональный колбэк прогресса
                function (error) {
                    console.error('Ошибка при загрузке модели:', error);
                }
            );

        }

        function visualizeBoundingBoxes(scene) {
            scene.traverse((object) => {
                // Проверяем, является ли объект мешем

                if (object.isMesh) {
                    // Исключаем конкретный объект, например, "Circle001"
                    if (object.name == "Circle001") return;

                    // Создаем BoxHelper для каждого меша


                    const boxHelper = new THREE.BoxHelper(object, 0x0000ff);
                    boxHelper.name = "boxHelper_" + object.name; // Добавляем имя для упрощения поиска
                    scene.add(boxHelper);
                    console.log(object);
                    console.log(boxHelper);
                }

                // Если объект является группой, рекурсивно проходим по его дочерним объектам
                /*  if (object.isGroup) {
                      object.traverse((child) => {
                          if (child.isMesh && child.name !== "Circle001") {
                              const boxHelper = new THREE.BoxHelper(child, 0x0000ff);
                              boxHelper.name = "boxHelper_" + child.name;
                              scene.add(boxHelper);
                          }
                      });
                  }
  
                  if (object instanceof THREE.Object3D) {
                      object.traverse((child) => {
                          if (child.isMesh && child.name !== "Circle001") {
                              const boxHelper = new THREE.BoxHelper(child, 0x0000ff);
                              boxHelper.name = "boxHelper_" + child.name;
                              scene.add(boxHelper);
                          }
                      });
                  }*/

            });

            // Логируем все дочерние элементы сцены
            console.log("Все дочерние элементы сцены:", scene.children);
        }



        let cube, bloomPass;
        let composer;

        function addBloomEffect(cube) {
            if (cube) {
                // Устанавливаем материал для куба с эмиссией
                cube.material.emissive = new THREE.Color(0xffffff);
                cube.material.emissiveIntensity = 1.0;
            }
        }

        // Настроим постобработку
        function setupPostProcessing() {
            // Создаем основной рендер-процесс
            const renderPass = new THREE.RenderPass(scene, camera);

            // Создаем bloom-эффект
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, // Интенсивность
                0.4, // Радиус
                0.85 // Порог
            );

            // Создаем render target для постобработки с сглаживанием
            const renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBFormat,
                antialias: true // Включаем сглаживание для постобработки
            });

            // Композитор для постобработки
            composer = new THREE.EffectComposer(renderer, renderTarget);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);
        }

        document.getElementById('3d-viewer').addEventListener('mousemove', onMouseMove);
        document.getElementById('3d-viewer').addEventListener('mousedown', onMouseDown);
        document.addEventListener('mouseup', onMouseUp);
        document.addEventListener('mousemove', onDocumentMouseMove);
        document.getElementById('3d-viewer').addEventListener('touchstart', onTouchStart);
        document.getElementById('3d-viewer').addEventListener('touchmove', onTouchMove);
        document.addEventListener('touchend', onTouchEnd);

        window.addEventListener('resize', function () {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setPixelRatio(1);
            // var renderWidth = container.clientWidth ;
            //var renderHeight = container.clientHeight;
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.domElement.style.width = '100%';
            renderer.domElement.style.height = '100%';
            renderer.domElement.style.imageRendering = 'auto';
            var size = new THREE.Vector2();
            renderer.getSize(size);
            console.log('devicePixelRatio:', window.devicePixelRatio);
            console.log('Текущая ширина рендера:', size.width);
            console.log('Текущая высота рендера:', size.height);
        });

        function animate() {
            // console.log('Рендер кадра');

            stats.begin(); // Начало измерения производительности

            requestAnimationFrame(animate);
            updateCameraPosition();

            renderer.render(scene, camera);

            // composer.render();

            // Обновляем маркер камеры
            // updateCameraMarker();
            // Логика обновления LOD
            /*  lod.update = function () {
                       const distance = camera.position.distanceTo(lod.position); // Расстояние от камеры до LOD
                       const currentLevel = lod.levels.findIndex(level => distance >= level.distance);
           
                       console.log(`Текущее расстояние до LOD: ${distance.toFixed(2)}`);
                       console.log(`Текущий уровень LOD: ${currentLevel >= 0 ? currentLevel : "Хай-полигональная модель"}`);
                   };

              lod.update(); // Вызываем метод обновления LOD*/
            // Рендер сцены для карты (вид сверху)
            // mapRenderer.render(scene, mapCamera);
            stats.end(); // Конец измерения производительности
        }

        init();
        animate();
    </script>
</body>

</html>