<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Viewer</title>
    <style>
        #3d-viewer {
            cursor: grab;
            position: absolute;
            z-index: 99;
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
            /* Отключаем стандартное поведение касания */
            -webkit-tap-highlight-color: transparent;
            /* Убирает синий эффект */
            outline: none;
        }

        #3d-viewer canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
            user-select: none;
            /* Отключаем выделение */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -khtml-user-select: none;
            -webkit-touch-callout: none;
            /* Отключаем вызовы в Android и iOS */
        }

        /* .cursor-pointer {
            cursor: pointer;
        }

        .cursor-clicking {
            cursor: grabbing;
        }*/
    </style>
</head>

<body>
    <div id="3d-viewer" style="width: 100%; height: 97vh;"></div>

   
   
   

    <label style="display: none;">
        Угол обзора (FOV)
        <input type="range" id="fovSlider" min="30" max="120" value="75" step="1" />
        <span id="fovValue">75</span>
    </label>

    <label style="display: none;">
        Загрузить GLB
        <input type="file" id="fileInput" accept=".glb" />
    </label>

    <label style="display: none;">
        Загрузить HDRI
        <input type="file" id="hdriInput" accept=".exr" />
    </label>

    <label style="display: none;">
        Экспозиция HDRI
        <input type="range" id="exposureSlider" min="0.1" max="5" value="1" step="0.1" />
        <span id="exposureValue">1</span>
    </label>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/environments/RoomEnvironment.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/loaders/EXRLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/threejs-utils@0.1.3/lib/stats.min.js"></script>

    <script>
        var scene = new THREE.Scene();
        var container = document.getElementById('3d-viewer');

        var renderWidth = container.clientWidth ;
        var renderHeight = container.clientHeight;
        var camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 200);


        var renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true/*, alpha: true*/ });
        renderer.setSize(renderWidth, renderHeight);
        renderer.setPixelRatio(1);

        renderer.domElement.style.width = '100%';
        renderer.domElement.style.height = '100%';
        renderer.domElement.style.imageRendering = 'auto';
        container.appendChild(renderer.domElement);

        var size = new THREE.Vector2();
        renderer.getSize(size);
        console.log('devicePixelRatio:', window.devicePixelRatio);
        console.log('Текущая ширина рендера:', size.width);
        console.log('Текущая высота рендера:', size.height);

        //renderer.shadowMap.enabled = true; // Включаем карту теней
       // renderer.shadowMap.type = THREE.BasicShadowMap; // Настройка типа теней (мягкие)
        // Установите начальное значение экспозиции
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = parseFloat(exposureSlider.value);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 0.2;
        renderer.outputEncoding = THREE.sRGBEncoding;

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();
        const environment = new THREE.RoomEnvironment();
        var defaultEnvMap = pmremGenerator.fromScene(environment).texture;
        scene.environment = defaultEnvMap;      

        var stats = new Stats();
        stats.showPanel(0); // 0 показывает FPS, 1 - время рендеринга, 2 - память
        document.body.appendChild(stats.dom);

        // Добавляем окружающий свет
      /*  const ambientLight = new THREE.AmbientLight(0xffffff, 1.3);
        scene.add(ambientLight); */   

       

        var loader = new THREE.GLTFLoader();

        document.getElementById('fileInput').addEventListener('change', function (event) {
            var file = event.target.files[0];
            if (file) {
                var reader = new FileReader();
                reader.onload = function (e) {
                    var contents = e.target.result;


                    loader.parse(contents, '', function (gltf) {
                        scene.add(gltf.scene);

                        gltf.scene.traverse(function (node) {
                            //console.log(node.type);
                            if (node.isMesh) {
                                console.log('Object is mesh');
                                // node.castShadow = true; // Объекты будут отбрасывать тени
                                // node.receiveShadow = true; // Объекты будут получать тени
                            }

                            if (node.isLight) {
                                console.log('Object is Light');
                                // node.castShadow = true; // Объекты будут отбрасывать тени
                                //  node.shadow.bias = -0.00001;
                            }
                        });
                        gltf.scene.traverse(function (node) {
                            if (node.isLight) {
                                scene.add(node);
                            }
                        });
                    }, function (error) {
                        console.error('Ошибка загрузки GLTF:', error);
                    });
                };
                reader.readAsArrayBuffer(file);
            }
        });

        var hdrTexture;
        var hdriInput = document.getElementById('hdriInput');

        hdriInput.addEventListener('change', function (event) {
            var file = event.target.files[0];
            if (file) {
                var reader = new FileReader();
                reader.onload = function (e) {
                    var arrayBuffer = e.target.result;
                    var exrLoader = new THREE.EXRLoader();
                    exrLoader.load(URL.createObjectURL(new Blob([arrayBuffer])), function (texture) {
                        hdrTexture = texture;

                        // Использование HDRI напрямую как фоновой текстуры
                        scene.background = texture;
                        // exrBackground = texture;
                        // Создание текстуры окружения из HDRI
                        var envMap = pmremGenerator.fromEquirectangular(hdrTexture).texture;
                        scene.environment = envMap;
                        // Настройка экспозиции
                        scene.environment.encoding = THREE.sRGBEncoding;

                        /*  // Создание сферы для окружения
                          const sphereGeometry = new THREE.SphereGeometry(500, 64, 64);
                          sphereGeometry.scale(-1, 1, 1);  // Инвертирование сферы, чтобы текстура была видна изнутри
  
                          // Создание материала с HDRI текстурой
                          const sphereMaterial = new THREE.MeshBasicMaterial({
                              map: texture,
                              side: THREE.BackSide
                          });
                          // Создание и добавление сферы в сцену
                          const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                          scene.add(sphere);*/


                        //hdrTexture.dispose();
                        pmremGenerator.dispose();
                        animate();
                    }, undefined, function (error) {
                        console.error('Ошибка загрузки EXR текстуры:', error);
                    });
                };
                reader.readAsArrayBuffer(file);
            }
        });
        

        
        var cameraHeight = 1.5;
        camera.position.set(1, cameraHeight, 1);
        camera.lookAt(3, cameraHeight, 1);


        // Создаем камеру для карты (вид сверху)
      /*    const mapCamera = new THREE.OrthographicCamera(-5, 5, 5, -5, 0.1, 100);
          mapCamera.position.set(0, 2.5, 0); // Камера расположена высоко и смотрит вниз
          mapCamera.layers.enable(1);
          mapCamera.lookAt(0, 0, 0); // Смотрит на центр сцены
  
          // Создаем рендер для миникарты
          const mapRenderer = new THREE.WebGLRenderer({ }); // Используйте alpha, если хотите видеть прозрачный фон
          mapRenderer.setSize(250, 250); // Размер карты
          mapRenderer.domElement.style.position = 'absolute'; // Позиционирование миникарты
          mapRenderer.domElement.style.top = '10px'; // Расположение снизу
          mapRenderer.domElement.style.left = '10px'; // Расположение слева
          mapRenderer.domElement.style.pointerEvents = 'none'; // Отключаем взаимодействие с миникартой
          container.appendChild(mapRenderer.domElement); // Добавляем миникарту в контейнер
          */  

        // Создаем материал для круга
        const circleMaterial1 = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // 

        // Создаем геометрию круга
        const circleGeometry1 = new THREE.CircleGeometry(0.2, 32); // Радиус 0.1, 32 сегмента

        // Создаем меш круга
        const circleMesh = new THREE.Mesh(circleGeometry1, circleMaterial1);
        circleMesh.position.set(camera.position.x, 0.1, camera.position.z); // Устанавливаем позицию на месте камеры
        circleMesh.rotation.x = -Math.PI / 2; // Поворачиваем круг, чтобы он был горизонтально
        circleMesh.layers.set(1);
        // Добавляем круг в сцену
        scene.add(circleMesh);
        // camera.layers.disable(1);
        // Функция для обновления положения маркера на карте
        function updateCameraMarker() {
            mapCamera.position.set(camera.position.x, 2.5, camera.position.z);
            circleMesh.position.set(camera.position.x, 0.1, camera.position.z);
        }

        
        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();

        var canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 256;
        var context = canvas.getContext('2d');
        context.fillStyle = 'rgba(255, 255, 255, 0)';
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.beginPath();
        context.arc(128, 128, 128, 0, Math.PI * 2);
        context.arc(128, 128, 110, 0, Math.PI * 2, true);
        context.closePath();
        context.fillStyle = 'rgba(255, 255, 255, 1)';
        context.fill();

        // Создание круга (должно выполняться один раз)
        const innerRadius = 0.08; // Внутренний радиус, который задает пустоту
        const outerRadius = 0.1;  // Внешний радиус
        const circleGeometry = new THREE.RingGeometry(innerRadius, outerRadius, 32); // Радиус 0.1
        const circleMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            side: THREE.DoubleSide,
            depthTest: false // Отключаем тестирование на глубину
        });
        const circle = new THREE.Mesh(circleGeometry, circleMaterial);
        // Устанавливаем высокий приоритет рендеринга для круга
        circle.renderOrder = 9999;
        scene.add(circle); // Добавляем круг на сцену

        var isMouseDown = false;
        var mouseX = 0;
        var mouseY = 0;
        var prevMouseX = 0;
        var prevMouseY = 0;
        var mouseDownTime = 0;
        var mouseMoved = false;
        var touchStartX = 0;
        var touchStartY = 0;



        // Обновите значение экспозиции и отобразите его
        function updateExposure() {
            var newExposure = parseFloat(exposureSlider.value);
            renderer.toneMappingExposure = newExposure;
            exposureValue.textContent = newExposure;
        }

        let lastMousePosition = { x: 0, y: 0 }; // Для хранения последней позиции мыши
        const MOVE_THRESHOLD = 5; // Пороговое значение для перемещения мыши (в пикселях)

        function onMouseMove(event) {
            // Преобразуем координаты мыши в диапазон [-1, 1]
            mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

            // Обновляем Raycaster
            raycaster.setFromCamera(mouse, camera);

            // Пересечения с объектами сцены, исключая круг
            var intersects = raycaster.intersectObjects(scene.children.filter(obj => obj !== circle), true);

            if (intersects.length > 0) {
                var intersect = intersects[0];

                // Устанавливаем позицию круга на точку пересечения
                circle.position.copy(intersect.point);

                // Получаем нормаль к поверхности
                const normal = intersect.face.normal.clone();

                // Выводим отладочную информацию
                // console.log('Intersection point:', intersect.point);
                // console.log('Intersection normal:', normal);

                // Инициализируем вектор "вверх"
                let up = new THREE.Vector3(0, 1, 0);

                // Если нормаль направлена вдоль оси X
                if (Math.abs(normal.x) > 0.9) {
                    // Используем ось Z как "вверх" для поверхностей, направленных вдоль оси X
                    up = new THREE.Vector3(0, 0, 1);
                }
                // Если нормаль направлена вдоль оси Z (например, {x: 0, y: 0, z: -1})
                else if (Math.abs(normal.z) > 0.9) {
                    // Используем ось Y как "вверх", чтобы круг правильно ориентировался по Z
                    up = new THREE.Vector3(0, 1, 0);
                }

                // Рассчитываем кватернион на основе нормали
                const quaternion = new THREE.Quaternion();
                quaternion.setFromUnitVectors(up, normal);

                // Применяем рассчитанный поворот
                circle.quaternion.copy(quaternion);

                // Делаем круг видимым
                circle.visible = true;
                container.classList.add('cursor-pointer');
                container.classList.remove('cursor-clicking');
            } else {
                // Если нет пересечений, скрываем круг
                circle.visible = false;
                container.classList.remove('cursor-pointer');
            }

            // Устанавливаем флаг перемещения мыши
            if (isMouseDown) {
                const distanceMoved = Math.sqrt(
                    Math.pow(event.clientX - lastMousePosition.x, 2) +
                    Math.pow(event.clientY - lastMousePosition.y, 2)
                );

                if (distanceMoved > MOVE_THRESHOLD) {
                    mouseMoved = true; // Устанавливаем флаг только если перемещение больше порога
                }
            }

            lastMousePosition.x = event.clientX; // Обновляем последнюю позицию
            lastMousePosition.y = event.clientY;
        }

        function onMouseDown(event) {
            if (event.button === 0) {
                mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
                mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

                lastMousePosition.x = event.clientX; // Сохраняем начальную позицию мыши
                lastMousePosition.y = event.clientY;

                mouseX = event.clientX;
                mouseY = event.clientY;
                prevMouseX = event.clientX;
                prevMouseY = event.clientY;
                isMouseDown = true;
                mouseDownTime = performance.now();
                mouseMoved = false;
                container.classList.add('cursor-clicking');
            }
        }

        function onMouseUp(event) {
            if (event.button === 0) {
                isMouseDown = false;
                container.classList.remove('cursor-clicking');

                var mouseUpTime = performance.now();
                var timeDiff = mouseUpTime - mouseDownTime;
                //console.log('клик:', timeDiff, mouseMoved);
                if (!mouseMoved) {
                    onClick(event); // Вызываем onClick только если мышь не двигалась
                }
            }
        }

// Переменные для визуализации raycast
let rayLine;
const rayLineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 }); // Красный цвет для линии
const rayLineGeometry = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0, 0, 0),  // Начальная точка
    new THREE.Vector3(0, 0, 0)   // Конечная точка
]);

// Создаем линию и добавляем ее в сцену
rayLine = new THREE.Line(rayLineGeometry, rayLineMaterial);
scene.add(rayLine);


       function onClick(event) {
    // Вычисление координат мыши
    mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
    mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

    // Установка луча
    raycaster.setFromCamera(mouse, camera);

    // Обновление линии для визуализации
    const rayStart = raycaster.ray.origin.clone(); // Начало луча (камера)
    let rayEnd; // Конец луча

    // Проверка пересечений
    const intersects = raycaster.intersectObjects(
        scene.children.filter(obj => obj !== circle), // Исключаем объект, если нужно
        true
    );

    if (intersects.length > 0) {
        // Точка пересечения
        rayEnd = intersects[0].point.clone(); 
    } else {
        // Если пересечений нет, линия до максимальной длины
        rayEnd = rayStart.clone().add(raycaster.ray.direction.clone().multiplyScalar(100));
    }

    // Обновление геометрии линии
   // rayLineGeometry.setFromPoints([rayStart, rayEnd]);

    if (intersects.length > 0) {
        const intersectPoint = intersects[0].point;
        intersectPoint.y = cameraHeight;
        moveToPosition(intersectPoint); // Движение к точке пересечения
    } else {
        console.log('Нет пересечений');
    }
}
      


        function moveToPosition(targetPosition) {
          
            var duration = 1000; // Продолжительность анимации
            var startPosition = camera.position.clone(); // Начальная позиция камеры
            var startTime = performance.now(); // Время старта
            var stopDistance = 0.5; // Расстояние, на котором остановится камера

            function animateMovement() {
                var elapsedTime = performance.now() - startTime; // Время, прошедшее с начала
                var t = elapsedTime / duration; // Нормализованное время для анимации

                // Линейная интерполяция позиции камеры
                if (t < 1) {
                    camera.position.lerpVectors(startPosition, targetPosition, t);

                    // Проверяем расстояние до целевой позиции
                    if (camera.position.distanceTo(targetPosition) > stopDistance) {
                        requestAnimationFrame(animateMovement); // Продолжаем анимацию
                    }
                } else {
                    // Если анимация завершена, но расстояние больше 0.2 метра, устанавливаем конечную позицию
                    if (camera.position.distanceTo(targetPosition) > stopDistance) {
                        camera.position.copy(targetPosition);
                    }
                }
            }

            animateMovement();
        }
       

       function init() {
    const loader = new THREE.GLTFLoader();
    loader.load(
            'flat_1C1.glb', // Путь к вашему файлу
            function (gltf) {
                // Добавляем загруженную модель в сцену
                scene.add(gltf.scene);
                console.log('Модель успешно загружена:', gltf);
                countTriangles(scene);
            },
            undefined, // Опциональный колбэк прогресса
            function (error) {
                console.error('Ошибка при загрузке модели:', error);
            }
        );
   /* loader.load(
        'flat_1C1.glb',
        function (gltf) {
            const sceneData = gltf.scene;

            sceneData.traverse(async function (child) {
                try {
                    if (child.isMesh) {
                        console.log(`Mesh: ${child.name}`);
                        console.log(`Mesh position:`, child.position);
                        const lod = new THREE.LOD();

                        // Загружаем low-poly модель
                        const lowModel = await loadLowPolyModel(loader, 'flat_1C1_low.glb', child.name);

                        if (lowModel) {
                            lowModel.updateMatrixWorld(true); // Обновляем мировую матрицу для low-poly модели
                            lod.addLevel(lowModel, 5); // Устанавливаем расстояние для low-poly
                            lowModel.material = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Красный для low-poly

                            lowModel.position.copy(child.position); // Устанавливаем позицию для low-poly модели
                        } else {
                            console.warn(`Low-poly object ${child.name} not found.`);
                        }

                        const highModel = child.clone();
                        highModel.updateMatrixWorld(true); // Обновляем мировую матрицу для high-poly модели
                        lod.addLevel(highModel, 1); // Устанавливаем расстояние для high-poly

                        // Обновляем мировую позицию для LOD
                        child.updateMatrixWorld();
                        var worldPosition = new THREE.Vector3();
                        child.getWorldPosition(worldPosition); // Получаем мировую позицию

                        lod.position.copy(worldPosition); // Устанавливаем позицию LOD в мировые координаты

                        console.log(`worldPosition:`, worldPosition);
                        console.log(`lod:`, lod.position);
                        console.log('Parent Position:', child.parent ? child.parent.position : 'No parent');

                        scene.add(lod); // Добавляем LOD в сцену

                        // Слушаем изменения уровня LOD
                        trackLOD(lod);
                    }
                } catch (error) {
                    console.error(`Error processing node ${child.name}:`, error);
                }
            });
        },
        undefined,
        function (error) {
            console.error('Error loading GLB:', error);
        }
    );*/
}


        // Функция для загрузки low-poly модели
       /* function loadLowPolyModel(loader, url, name) {
            return new Promise((resolve, reject) => {
                loader.load(
                    url,
                    function (gltf) {
                        const model = gltf.scene.getObjectByName(name);
                        if (model) {
                            model.updateMatrixWorld(true); // Обновляем мировую матрицу перед возвратом модели
                            resolve(model);
                        } else {
                            reject(new Error(`Model ${name} not found in ${url}`));
                        }
                    },
                    undefined,
                    function (error) {
                        console.error(`Error loading ${url}:`, error);
                        reject(error);
                    }
                );
            });
        }*/




        function countTriangles(scene) {
            let totalTriangles = 0;

            scene.traverse((object) => {
                 console.log(object.name);
                 console.log(object.type);
                if (object.isMesh) { // Проверяем, что объект является мешем
                    const geometry = object.geometry;

                    if (geometry.index !== null) {
                        // Считаем треугольники для геометрии с индексом
                        totalTriangles += geometry.index.count / 3;
                    } else if (geometry.attributes.position !== undefined) {
                        // Считаем треугольники для геометрии без индекса
                        totalTriangles += geometry.attributes.position.count / 3;
                    }
                }
            });





            console.log(`Общее количество треугольников: ${totalTriangles}`);
            return totalTriangles;
        }

        var cameraRotation = new THREE.Euler().setFromQuaternion(camera.quaternion, 'XYZ');
        var yaw = cameraRotation.y;
        var pitch = cameraRotation.x;

        function onDocumentMouseMove(event) {
            if (isMouseDown) {
                var deltaX = event.clientX - prevMouseX;
                var deltaY = event.clientY - prevMouseY;

                var sensitivity = 0.002;

                yaw += deltaX * sensitivity;
                pitch += deltaY * sensitivity;

                pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));

                var yawQuaternion = new THREE.Quaternion();
                yawQuaternion.setFromEuler(new THREE.Euler(0, yaw, 0, 'XYZ'));

                var pitchQuaternion = new THREE.Quaternion();
                pitchQuaternion.setFromEuler(new THREE.Euler(pitch, 0, 0, 'XYZ'));

                camera.quaternion.copy(yawQuaternion);
                camera.quaternion.multiply(pitchQuaternion);

                prevMouseX = event.clientX;
                prevMouseY = event.clientY;
            }
        }

        function onTouchStart(event) {


            if (event.touches.length === 1) {

                var touch = event.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                isMouseDown = true;
                mouseMoved = false;
                mouseDownTime = performance.now();
                container.classList.add('cursor-clicking');
                //event.preventDefault();

            }

        }

        function onTouchMove(event) {

            if (event.touches.length === 1 && isMouseDown) {


                var touch = event.touches[0];
                var deltaX = touch.clientX - touchStartX;
                var deltaY = touch.clientY - touchStartY;

                var sensitivity = 0.002;

                yaw += deltaX * sensitivity;
                pitch += deltaY * sensitivity;

                pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));

                var yawQuaternion = new THREE.Quaternion();
                yawQuaternion.setFromEuler(new THREE.Euler(0, yaw, 0, 'XYZ'));

                var pitchQuaternion = new THREE.Quaternion();
                pitchQuaternion.setFromEuler(new THREE.Euler(pitch, 0, 0, 'XYZ'));

                camera.quaternion.copy(yawQuaternion);
                camera.quaternion.multiply(pitchQuaternion);

                touchStartX = touch.clientX;
                touchStartY = touch.clientY;

                mouseMoved = true;
                event.preventDefault();
            }
        }

        function onTouchEnd(event) {

            if (event.changedTouches.length === 1) {
                isMouseDown = false;
                container.classList.remove('cursor-clicking');

                var touchEndTime = performance.now();
                var timeDiff = touchEndTime - mouseDownTime;

                if (!mouseMoved && timeDiff < 200) {
                    onClick(event);
                }
            }
        }


        // Управление камерой через клавиши
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            KeyW: false,
            KeyA: false,
            KeyS: false,
            KeyD: false
        };

        // Обработчики событий для нажатия и отпускания клавиш
        document.addEventListener('keydown', (event) => {
            console.log('devicePixelRatio:', window.devicePixelRatio);
            if (event.code in keys) {
                keys[event.code] = true;
            }
        });

        document.addEventListener('keyup', (event) => {
            if (event.code in keys) {
                keys[event.code] = false;
            }
        });

        // Создание Raycaster для обнаружения столкновений

        const collisionDistance = 0.5; // Минимальное расстояние до объекта
const rayHeightSteps = 5; // Количество проверок по высоте
const rayHeightInterval = 0.2; // Интервал между лучами по высоте

function checkCollisions(direction) {
    for (let i = 0; i < rayHeightSteps; i++) {
        // Смещаем положение луча вверх на определенную высоту
        const rayOrigin = camera.position.clone();
        rayOrigin.y -= i * rayHeightInterval;

        raycaster.set(rayOrigin, direction.normalize());
        const intersects = raycaster.intersectObjects(scene.children, true);

        if (intersects.length > 0 && intersects[0].distance < collisionDistance) {
            return true; // Обнаружено столкновение
        }
    }
    return false; // Столкновений нет
}

        // Обновление позиции камеры
        function updateCameraPosition() {
            const speed = 0.02;
            const direction = new THREE.Vector3();

            // Движение вперед и назад
            if (keys.ArrowUp || keys.KeyW) {
                camera.getWorldDirection(direction);
                if (!checkCollisions(direction.clone().multiplyScalar(speed))) {
                    camera.position.addScaledVector(direction, speed);
                }
            }
            if (keys.ArrowDown || keys.KeyS) {
                camera.getWorldDirection(direction);
                if (!checkCollisions(direction.clone().multiplyScalar(-speed))) {
                    camera.position.addScaledVector(direction, -speed);
                }
            }

            // Движение влево и вправо
            if (keys.ArrowLeft || keys.KeyA) {
                camera.getWorldDirection(direction);
                const left = new THREE.Vector3().crossVectors(camera.up, direction).normalize();
                if (!checkCollisions(left.clone().multiplyScalar(speed))) {
                    camera.position.addScaledVector(left, speed);
                }
            }
            if (keys.ArrowRight || keys.KeyD) {
                camera.getWorldDirection(direction);
                const right = new THREE.Vector3().crossVectors(direction, camera.up).normalize();
                if (!checkCollisions(right.clone().multiplyScalar(speed))) {
                    camera.position.addScaledVector(right, speed);
                }
            }

            // Фиксируем высоту камеры на уровне 1.5
            camera.position.y = 1.5;
        }


        document.getElementById('3d-viewer').addEventListener('mousemove', onMouseMove);
        document.getElementById('3d-viewer').addEventListener('mousedown', onMouseDown);
        document.addEventListener('mouseup', onMouseUp);
        document.addEventListener('mousemove', onDocumentMouseMove);

        document.getElementById('3d-viewer').addEventListener('touchstart', onTouchStart);
        document.getElementById('3d-viewer').addEventListener('touchmove', onTouchMove);
        document.addEventListener('touchend', onTouchEnd);
        exposureSlider.addEventListener('input', updateExposure);

        window.addEventListener('resize', function () {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
             renderer.setPixelRatio(1);
           // var renderWidth = container.clientWidth ;
            //var renderHeight = container.clientHeight;
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.domElement.style.width = '100%';
            renderer.domElement.style.height = '100%';
            renderer.domElement.style.imageRendering = 'auto';
            var size = new THREE.Vector2();
            renderer.getSize(size);
            console.log('devicePixelRatio:', window.devicePixelRatio);
            console.log('Текущая ширина рендера:', size.width);
            console.log('Текущая высота рендера:', size.height);
        });

        var fovSlider = document.getElementById('fovSlider');
        var fovValue = document.getElementById('fovValue');
        fovValue.textContent = fovSlider.value;

        function updateFOV() {
            var newFOV = parseFloat(fovSlider.value);
            camera.fov = newFOV;
            camera.updateProjectionMatrix();
            fovValue.textContent = newFOV;
        }

        fovSlider.addEventListener('input', updateFOV);

        



        function animate() {
            stats.begin(); // Начало измерения производительности
            requestAnimationFrame(animate);
            updateCameraPosition();

            renderer.render(scene, camera);

            // Обновляем маркер камеры
            // updateCameraMarker();
            // Логика обновления LOD
            /*  lod.update = function () {
                       const distance = camera.position.distanceTo(lod.position); // Расстояние от камеры до LOD
                       const currentLevel = lod.levels.findIndex(level => distance >= level.distance);
           
                       console.log(`Текущее расстояние до LOD: ${distance.toFixed(2)}`);
                       console.log(`Текущий уровень LOD: ${currentLevel >= 0 ? currentLevel : "Хай-полигональная модель"}`);
                   };

              lod.update(); // Вызываем метод обновления LOD*/
            // Рендер сцены для карты (вид сверху)
            // mapRenderer.render(scene, mapCamera);
            stats.end(); // Конец измерения производительности
        }

        init();
        animate();
    </script>
</body>

</html>