<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Viewer</title>
    <style>
        #3d-viewer {
            cursor: grab;
            position: absolute;
            z-index: 99;
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
            /* Отключаем стандартное поведение касания */
            -webkit-tap-highlight-color: transparent;
            /* Убирает синий эффект */
            outline: none;
        }

        #3d-viewer canvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
            user-select: none;
            /* Отключаем выделение */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -khtml-user-select: none;
            -webkit-touch-callout: none;
            /* Отключаем вызовы в Android и iOS */
        }

        /* .cursor-pointer {
            cursor: pointer;
        }

        .cursor-clicking {
            cursor: grabbing;
        }*/
    </style>
</head>

<body>
    <div id="3d-viewer" style="width: 100%; height: 97vh;"></div>
    <script src="https://cdn.jsdelivr.net/npm/threejs-utils@0.1.3/lib/stats.min.js"></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/environments/RoomEnvironment.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/loaders/EXRLoader.js"></script>
  
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/shaders/LuminosityHighPassShader.js"></script> -->
    <!-- <script src="js/controls.js"></script>
    <script src="js/controlstouch.js"></script>
    <script src="js/controlskeyboard.js"></script>
    <script src="js/debug.js"></script> -->

    <script type="importmap">
        {
          "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.172.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.172.0/examples/jsm/"
          }
        }
      </script>

    <script type="module">
        import * as THREE from 'three';

        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        //import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        var scene = new THREE.Scene();

        var container = document.getElementById('3d-viewer');
        var renderWidth = container.clientWidth;
        var renderHeight = container.clientHeight;

        var camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 200);
        var cameraHeight = 1.5;
        camera.position.set(1, cameraHeight, 1);
        camera.lookAt(3, cameraHeight, 1);




        scene.add(camera);

        var renderer = new THREE.WebGLRenderer({ antialias: true, /*preserveDrawingBuffer: true/*, alpha: true*/ });
        renderer.setSize(renderWidth, renderHeight);
        renderer.setPixelRatio(1);
        renderer.domElement.style.width = '100%';
        renderer.domElement.style.height = '100%';
        renderer.domElement.style.imageRendering = 'auto';
        container.appendChild(renderer.domElement);

        var size = new THREE.Vector2();
        renderer.getSize(size);
        console.log('devicePixelRatio:', window.devicePixelRatio);
        console.log('Текущая ширина рендера:', size.width);
        console.log('Текущая высота рендера:', size.height);

        /* renderer.shadowMap.enabled = true; // Включаем карту теней
         renderer.shadowMap.type = THREE.BasicShadowMap; // Настройка типа теней (мягкие)*/
        // Установите начальное значение экспозиции
        // renderer.toneMapping = THREE.ReinhardToneMapping;

        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        //renderer.toneMappingExposure = 0.8;
        //renderer.outputEncoding = THREE.sRGBEncoding;

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();
        const environment = new RoomEnvironment();
        var defaultEnvMap = pmremGenerator.fromScene(environment).texture;
        scene.environment = defaultEnvMap;

        var stats = new Stats();
        stats.showPanel(0); // 0 показывает FPS, 1 - время рендеринга, 2 - память
        document.body.appendChild(stats.dom);


        // Добавляем окружающий свет
        /*  const ambientLight = new THREE.AmbientLight(0xffffff, 1.3);
          scene.add(ambientLight); */



        var loader = new GLTFLoader();




        // Создаем камеру для карты (вид сверху)
        /*    const mapCamera = new THREE.OrthographicCamera(-5, 5, 5, -5, 0.1, 100);
            mapCamera.position.set(0, 2.5, 0); // Камера расположена высоко и смотрит вниз
            mapCamera.layers.enable(1);
            mapCamera.lookAt(0, 0, 0); // Смотрит на центр сцены
    
            // Создаем рендер для миникарты
            const mapRenderer = new THREE.WebGLRenderer({ }); // Используйте alpha, если хотите видеть прозрачный фон
            mapRenderer.setSize(250, 250); // Размер карты
            mapRenderer.domElement.style.position = 'absolute'; // Позиционирование миникарты
            mapRenderer.domElement.style.top = '10px'; // Расположение снизу
            mapRenderer.domElement.style.left = '10px'; // Расположение слева
            mapRenderer.domElement.style.pointerEvents = 'none'; // Отключаем взаимодействие с миникартой
            container.appendChild(mapRenderer.domElement); // Добавляем миникарту в контейнер
            */

        // Создаем материал для круга
        /* const circleMaterial1 = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // 
 
         // Создаем геометрию круга
         const circleGeometry1 = new THREE.CircleGeometry(0.2, 32); // Радиус 0.1, 32 сегмента
 
         // Создаем меш круга
         const circleMesh = new THREE.Mesh(circleGeometry1, circleMaterial1);
         circleMesh.position.set(camera.position.x, 0.1, camera.position.z); // Устанавливаем позицию на месте камеры
         circleMesh.rotation.x = -Math.PI / 2; // Поворачиваем круг, чтобы он был горизонтально
         circleMesh.layers.set(1);*/
        // Добавляем круг в сцену
        // scene.add(circleMesh);
        camera.layers.enableAll();

        // Функция для обновления положения маркера на карте
        function updateCameraMarker() {
            mapCamera.position.set(camera.position.x, 2.5, camera.position.z);
            circleMesh.position.set(camera.position.x, 0.1, camera.position.z);
        }


        var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();

        var canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 256;
        var context = canvas.getContext('2d');
        context.fillStyle = 'rgba(255, 255, 255, 0)';
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.beginPath();
        context.arc(128, 128, 128, 0, Math.PI * 2);
        context.arc(128, 128, 110, 0, Math.PI * 2, true);
        context.closePath();
        context.fillStyle = 'rgba(255, 255, 255, 1)';
        context.fill();

        // Создание круга (должно выполняться один раз)
        const innerRadius = 0.08; // Внутренний радиус, который задает пустоту
        const outerRadius = 0.1;  // Внешний радиус
        const circleGeometry = new THREE.RingGeometry(innerRadius, outerRadius, 32); // Радиус 0.1
        const circleMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            side: THREE.DoubleSide,
            depthTest: false // Отключаем тестирование на глубину
        });
        const circle = new THREE.Mesh(circleGeometry, circleMaterial);
        // Устанавливаем высокий приоритет рендеринга для круга
        circle.renderOrder = 9999;
        scene.add(circle); // Добавляем круг на сцену

        var isMouseDown = false;
        var mouseX = 0;
        var mouseY = 0;
        var prevMouseX = 0;
        var prevMouseY = 0;
        var mouseDownTime = 0;
        var mouseMoved = false;
        var touchStartX = 0;
        var touchStartY = 0;






        let currentCameraQuaternion = camera.quaternion.clone();  // Текущее состояние кватерниона камеры

        // Начальная ориентация камеры
        let isAnimating = false;
        let yaw = 0;
        let pitch = 0;
        var cameraRotation = new THREE.Euler().setFromQuaternion(camera.quaternion, 'XYZ');
        yaw = cameraRotation.y;
        pitch = cameraRotation.x;
        // Переменные для визуализации raycast
        let rayLine;
        const rayLineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 }); // Красный цвет для линии
        const rayLineGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),  // Начальная точка
            new THREE.Vector3(0, 0, 0)   // Конечная точка
        ]);

        /* const clickMarkerGeometry = new THREE.SphereGeometry(0.1, 32, 32); // Сфера диаметром 0.1
         const clickMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // Синий цвет
         let clickMarker = new THREE.Mesh(clickMarkerGeometry, clickMarkerMaterial);
         scene.add(clickMarker); // Добавляем в сцену*/

        // Создаем линию и добавляем ее в сцену
        rayLine = new THREE.Line(rayLineGeometry, rayLineMaterial);
        scene.add(rayLine);




        const bloomLayer = new THREE.Layers(); // Для блума
        function init() {

            const loader = new GLTFLoader();
            loader.load('flat_1C1.glb', // Путь к вашему файлу
                function (gltf) {
                    // Добавляем загруженную модель в сцену
                    scene.add(gltf.scene);
                    console.log('Модель успешно загружена:', gltf);

                    // Обрабатываем материалы модели
                    gltf.scene.traverse((node) => {
                        // console.log("Объект: ", node); // Имя объекта

                        if (node.isMesh && node.material) {
                            const material = node.material;
                            node.updateMatrixWorld(true);

                            /* const geometry = node.geometry;
                             if (geometry.attributes.uv1) {
                                 console.log(`Объект ${node.name} содержит дополнительный UV-набор (uv1).`);
                             }*/

                            // Вычисляем границы объекта в мировых координатах
                            const boundingBox = new THREE.Box3().setFromObject(node);

                            // Создаем BoxHelper и корректируем его по мировым координатам
                            const boxHelper = new THREE.BoxHelper(node, 0x0000ff);
                            boxHelper.name = "boxHelper_" + node.name;

                            // Применяем матрицу трансформации объекта
                            boxHelper.position.copy(node.getWorldPosition(new THREE.Vector3())); // Переносим BoxHelper в мировую позицию
                            boxHelper.scale.copy(node.getWorldScale(new THREE.Vector3())); // Учитываем масштаб объекта
                            boxHelper.rotation.setFromRotationMatrix(node.matrixWorld); // Учитываем вращение объекта
                            boxHelper.visible = false;
                            // Добавляем BoxHelper в сцену
                            scene.add(boxHelper);

                            // console.log("Меш:", node);
                            // console.log("BoxHelper:", boxHelper);
                            // console.log("Границы в мировых координатах:", boundingBox.min, boundingBox.max);

                            // Проверяем, есть ли у материала карта эмиссии
                            /*  if (material.map) console.log('Base Color Map:', material.map);
                              if (material.normalMap) console.log('Normal Map:', material.normalMap);
                              if (material.metalnessMap) console.log('Metallic Map:', material.metalnessMap);
                              if (material.roughnessMap) console.log('Roughness Map:', material.roughnessMap);
                              if (material.emissiveMap) console.log('Emissive Map:', material.emissiveMap);*/

                            // Если объект с именем "Cube", то добавляем точечный свет
                            if (node.name === "Hall_lamp1") {
                                material.emissiveIntensity = 1;
                                //cube = node; // Сохраняем ссылку на куб для дальнейшей работы с ним
                                node.layers.enable(bloomLayer); // Включаем слой для блума
                                material.emissiveIntensity = 1;
                                console.log('Интенсивность эмиссии для Cube установлена в 20');
                            }

                            if (material.emissiveMap) {
                                console.log('Интенсивность эмиссии:', material.emissiveIntensity, node.name);

                                if (node.material) { // Проверяем, есть ли материал у объекта

                                    console.log("Материал: ", node.material.name); // Название материала
                                }
                                // Логируем цвет эмиссии
                                console.log('Цвет эмиссии:', material.emissive.getHexString());

                            }
                        }
                    });

                    // Устанавливаем блум для куба
                    /*  if (cube) {
                          addBloomEffect(cube);
                      }*/

                    // Настроим эффект композиции
                    // setupPostProcessing();

                    countTriangles(scene);
                    //visualizeBoundingBoxes(scene);
                    console.log("Все дочерние элементы сцены после :", scene.children);
                },
                undefined, // Опциональный колбэк прогресса
                function (error) {
                    console.error('Ошибка при загрузке модели:', error);
                }
            );

        }

        function visualizeBoundingBoxes(scene) {
            scene.traverse((object) => {
                // Проверяем, является ли объект мешем

                if (object.isMesh) {
                    // Исключаем конкретный объект, например, "Circle001"
                    if (object.name == "Circle001") return;

                    // Создаем BoxHelper для каждого меша


                    const boxHelper = new THREE.BoxHelper(object, 0x0000ff);
                    boxHelper.name = "boxHelper_" + object.name; // Добавляем имя для упрощения поиска
                    scene.add(boxHelper);
                    console.log(object);
                    console.log(boxHelper);
                }

                // Если объект является группой, рекурсивно проходим по его дочерним объектам
                /*  if (object.isGroup) {
                      object.traverse((child) => {
                          if (child.isMesh && child.name !== "Circle001") {
                              const boxHelper = new THREE.BoxHelper(child, 0x0000ff);
                              boxHelper.name = "boxHelper_" + child.name;
                              scene.add(boxHelper);
                          }
                      });
                  }
  
                  if (object instanceof THREE.Object3D) {
                      object.traverse((child) => {
                          if (child.isMesh && child.name !== "Circle001") {
                              const boxHelper = new THREE.BoxHelper(child, 0x0000ff);
                              boxHelper.name = "boxHelper_" + child.name;
                              scene.add(boxHelper);
                          }
                      });
                  }*/

            });

            // Логируем все дочерние элементы сцены
            console.log("Все дочерние элементы сцены:", scene.children);
        }



        let cube, bloomPass;
        let composer;

        function addBloomEffect(cube) {
            if (cube) {
                // Устанавливаем материал для куба с эмиссией
                cube.material.emissive = new THREE.Color(0xffffff);
                cube.material.emissiveIntensity = 1.0;
            }
        }

        // Настроим постобработку
        function setupPostProcessing() {
            // Создаем основной рендер-процесс
            const renderPass = new THREE.RenderPass(scene, camera);

            // Создаем bloom-эффект
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, // Интенсивность
                0.4, // Радиус
                0.85 // Порог
            );

            // Создаем render target для постобработки с сглаживанием
            const renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBFormat,
                antialias: true // Включаем сглаживание для постобработки
            });

            // Композитор для постобработки
            composer = new THREE.EffectComposer(renderer, renderTarget);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);
        }


        // Обновление позиции камеры
        function updateCameraPosition() {
            const speed = 0.02;
            const direction = new THREE.Vector3();

            // Движение вперед и назад
            if (keys.ArrowUp || keys.KeyW) {
                camera.getWorldDirection(direction);
                if (!checkCollisions(direction.clone().multiplyScalar(speed))) {
                    camera.position.addScaledVector(direction, speed);
                }
            }
            if (keys.ArrowDown || keys.KeyS) {
                camera.getWorldDirection(direction);
                if (!checkCollisions(direction.clone().multiplyScalar(-speed))) {
                    camera.position.addScaledVector(direction, -speed);
                }
            }

            // Движение влево и вправо
            if (keys.ArrowLeft || keys.KeyA) {
                camera.getWorldDirection(direction);
                const left = new THREE.Vector3().crossVectors(camera.up, direction).normalize();
                if (!checkCollisions(left.clone().multiplyScalar(speed))) {
                    camera.position.addScaledVector(left, speed);
                }
            }
            if (keys.ArrowRight || keys.KeyD) {
                camera.getWorldDirection(direction);
                const right = new THREE.Vector3().crossVectors(direction, camera.up).normalize();
                if (!checkCollisions(right.clone().multiplyScalar(speed))) {
                    camera.position.addScaledVector(right, speed);
                }
            }
            camera.position.y = 1.5;
        }


        // Управление камерой через клавиши
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            KeyW: false,
            KeyA: false,
            KeyS: false,
            KeyD: false
        };

        // Обработчики событий для нажатия и отпускания клавиш
        document.addEventListener('keydown', (event) => {
            console.log('devicePixelRatio:', window.devicePixelRatio);
            if (event.code in keys) {
                keys[event.code] = true;
            }
        });

        document.addEventListener('keyup', (event) => {
            if (event.code in keys) {
                keys[event.code] = false;
            }
        });

        // Создание Raycaster для обнаружения столкновений

        const collisionDistance = 0.5; // Минимальное расстояние до объекта
        const rayHeightSteps = 5; // Количество проверок по высоте
        const rayHeightInterval = 0.2; // Интервал между лучами по высоте

        function checkCollisions(direction) {
            // return false;
            for (let i = 0; i < rayHeightSteps; i++) {
                // Смещаем положение луча вверх на определенную высоту
                const rayOrigin = camera.position.clone();
                rayOrigin.y -= i * rayHeightInterval;

                raycaster.set(rayOrigin, direction.normalize());
                //const intersects = raycaster.intersectObjects(scene.children, true);
                var intersects = raycaster.intersectObjects(
                    scene.children.filter(obj => !(obj instanceof THREE.BoxHelper) && obj !== circle),
                    true
                );
                intersects = intersects.filter(intersect => !(intersect.object instanceof THREE.BoxHelper));

                if (intersects.length > 0 && intersects[0].distance < collisionDistance) {
                    return true; // Обнаружено столкновение
                }
            }
            return false; // Столкновений нет
        }


        function onMouseMove(event) {
            // Преобразуем координаты мыши в диапазон [-1, 1]
            mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

            // Обновляем Raycaster
            raycaster.setFromCamera(mouse, camera);

            // Пересечения с объектами сцены, исключая круг
            var intersects = raycaster.intersectObjects(
                scene.children.filter(obj => !(obj instanceof THREE.BoxHelper) && obj !== circle),
                true
            );
            intersects = intersects.filter(intersect => !(intersect.object instanceof THREE.BoxHelper));

            /* if (intersects.length > 0) {
                 intersects.forEach(intersect => {
                     console.log("Пересечен объект:", intersect.object);
                 });
             } else {
                 console.log("Пересечений не было.");
             }*/

            if (intersects.length > 0) {
                var intersect = intersects[0];

                // Устанавливаем позицию круга на точку пересечения
                circle.position.copy(intersect.point);
                const normal = intersect.face.normal.clone(); // Нормаль поверхности

                // Поворачиваем круг в направлении нормали
                const quaternion = new THREE.Quaternion().setFromUnitVectors(
                    new THREE.Vector3(0, 0, 1), // Ось нормали по умолчанию
                    normal.normalize() // Нормаль к поверхности
                );
                circle.quaternion.copy(quaternion);

                // Делаем круг видимым
                circle.visible = true;
                container.classList.add('cursor-pointer');
                container.classList.remove('cursor-clicking');
            } else {
                // Если нет пересечений, скрываем круг
                circle.visible = false;
                container.classList.remove('cursor-pointer');
            }

            // Устанавливаем флаг перемещения мыши
            if (isMouseDown) {
                const distanceMoved = Math.sqrt(
                    Math.pow(event.clientX - lastMousePosition.x, 2) +
                    Math.pow(event.clientY - lastMousePosition.y, 2)
                );

                if (distanceMoved > MOVE_THRESHOLD) {
                    mouseMoved = true; // Устанавливаем флаг только если перемещение больше порога
                }
            }

            lastMousePosition.x = event.clientX; // Обновляем последнюю позицию
            lastMousePosition.y = event.clientY;
        }

        function onMouseDown(event) {
            if (event.button === 0) {
                mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
                mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

                lastMousePosition.x = event.clientX; // Сохраняем начальную позицию мыши
                lastMousePosition.y = event.clientY;

                mouseX = event.clientX;
                mouseY = event.clientY;
                prevMouseX = event.clientX;
                prevMouseY = event.clientY;
                isMouseDown = true;
                mouseDownTime = performance.now();
                mouseMoved = false;
                container.classList.add('cursor-clicking');
            }
        }

        function onMouseUp(event) {
            if (event.button === 0) {
                isMouseDown = false;
                container.classList.remove('cursor-clicking');

                var mouseUpTime = performance.now();
                var timeDiff = mouseUpTime - mouseDownTime;
                // console.log('клик:', timeDiff, mouseMoved);
                if (!mouseMoved) {
                    onClick(event); // Вызываем onClick только если мышь не двигалась
                }
            }
        }

        let lastMousePosition = { x: 0, y: 0 }; // Для хранения последней позиции мыши
        const MOVE_THRESHOLD = 5; // Пороговое значение для перемещения мыши (в пикселях)

        // Параметры "человека"
        const personHeight = 1;
        const personRadius = 0.2; // Примерный радиус для проверки столкновений

        // Функция для проверки столкновения с BoxHelper
        function isColliding(position, log = false) {

            for (const child of scene.children) {
                if (child.name === "boxHelper_outer_walls")
                    continue;
                if (child.name === "boxHelper_Body45")
                    continue;
                if (child.name === "boxHelper_Body45_2")
                    continue;
                if (child instanceof THREE.BoxHelper) {
                    const box = new THREE.Box3().setFromObject(child.object);
                    const personBox = new THREE.Box3(
                        new THREE.Vector3(position.x - personRadius, 0.2, position.z - personRadius),
                        new THREE.Vector3(position.x + personRadius, 1.5, position.z + personRadius)
                    );
                    if (box.intersectsBox(personBox)) {
                        if (log) {
                            console.log("Столкновение ", child);
                            console.log("Столкновение ", personBox);
                        }

                        return true; // Столкновение есть
                    }
                }
            }
            return false; // Столкновения нет
        }


        let calculatedPoints = [];

        // Функция для очистки всех предыдущих точек
        function clearCalculatedPoints() {
            calculatedPoints.forEach(point => {
                scene.remove(point); // Удаляем точку из сцены
                point.geometry.dispose(); // Освобождаем память геометрии
                point.material.dispose(); // Освобождаем память материала
            });
            calculatedPoints = []; // Очищаем массив
        }

        // Функция для поиска безопасной точки рядом с целевой
        function findSafePosition(targetPosition, searchRadius = 0.5) {
            let wallAndCeilingsBox = null;

            for (const child of scene.children) {
                if (child.name === "boxHelper_Body45" && child instanceof THREE.BoxHelper) {
                    wallAndCeilingsBox = new THREE.Box3().setFromObject(child.object);
                    break;
                }
            }

            if (!wallAndCeilingsBox) {
                console.error("boxHelper_wall_and_ceillings не найден!");
                return null;
            }

            let closestSafePosition = null;
            let closestDistance = Infinity;

            const numChecks = 32;
            const raycaster = new THREE.Raycaster(); // Создаем Raycaster один раз

            // Предварительная подготовка: материал и геометрия для точек
            const visibleMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // Зеленый - для видимых точек
            const blockedMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Красный - для невидимых точек
            const blocked2Material = new THREE.MeshBasicMaterial({ color: 0xfff000 }); // Красный - для невидимых точек
            const sphereGeometry = new THREE.SphereGeometry(0.05, 16, 16); // Радиус 0.1, сегменты 16

            clearCalculatedPoints(); // Очистка перед новым расчетом

            for (let i = 0; i < numChecks; i++) {
                const angle = (i / numChecks) * Math.PI * 2;
                const checkPosition = new THREE.Vector3(
                    targetPosition.x + searchRadius * Math.cos(angle),
                    cameraHeight, // Устанавливаем корректную высоту
                    targetPosition.z + searchRadius * Math.sin(angle)
                );

                if (checkPosition.distanceTo(camera.position) < 0.5) continue;
                let materialToUse;

                if (wallAndCeilingsBox.containsPoint(checkPosition)) {
                    if (!isColliding(checkPosition, true)) {
                        // Проверка видимости с помощью Raycasting
                        const direction = checkPosition.clone().sub(camera.position).normalize();
                        raycaster.set(camera.position, direction);

                        var intersects = raycaster.intersectObjects(
                            scene.children.filter(obj => !(obj instanceof THREE.BoxHelper) && obj !== circle && obj !== scene.getObjectByName("Body45") && obj !== scene.getObjectByName("Body45_2")),
                            true
                        );

                        let materialToUse;

                        if (intersects.length === 0 || intersects[0].distance > checkPosition.distanceTo(camera.position)) {
                            // Точка видна
                            materialToUse = visibleMaterial;
                            const distance = targetPosition.distanceTo(checkPosition);
                            if (distance < closestDistance) {
                                closestDistance = distance;
                                closestSafePosition = checkPosition;
                            }
                        } else {
                            // Точка невидима
                            materialToUse = blockedMaterial;
                            console.log("Точка не видна из-за:", intersects[0].object);
                        }

                        // Визуализация точки

                    }
                    else {
                        materialToUse = blocked2Material;
                    }
                }


                /* const pointMesh = new THREE.Mesh(sphereGeometry, materialToUse);
                 pointMesh.position.copy(checkPosition);
                 scene.add(pointMesh); // Добавляем точку в сцену
                 calculatedPoints.push(pointMesh); // Сохраняем ссылку на точку*/
            }


            if (closestSafePosition) {
                console.log("Найдена ближайшая безопасная и видимая позиция:", closestSafePosition);
            } else {
                console.log("В радиусе", searchRadius, "не найдена безопасная и видимая позиция внутри boxHelper_wall_and_ceillings");
            }
            return closestSafePosition;
        }

        function onClick(event) {
            // Вычисление координат мыши
            mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;


            raycaster.setFromCamera(mouse, camera);
            console.log(mouse.x, mouse.y);

            // Обновление линии для визуализации
            const rayStart = raycaster.ray.origin.clone(); // Начало луча (камера)
            let rayEnd; // Конец луча

            // Проверка пересечений
            var intersects = raycaster.intersectObjects(
                scene.children.filter(obj => !(obj instanceof THREE.BoxHelper) && obj !== circle),
                true
            );
            intersects = intersects.filter(intersect => !(intersect.object instanceof THREE.BoxHelper));

            if (intersects.length > 0) {
                // Точка пересечения
                rayEnd = intersects[0].point.clone();
                // clickMarker.position.copy(rayEnd);
            } else {
                // Если пересечений нет, линия до максимальной длины
                rayEnd = rayStart.clone().add(raycaster.ray.direction.clone().multiplyScalar(100));

            }

            // Обновление геометрии линии
            // rayLineGeometry.setFromPoints([rayStart, rayEnd]);

            if (intersects.length > 0) {
                let intersectPoint = intersects[0].point.clone();
                var clickPoint = intersects[0].point.clone();

                var startPosition = camera.position.clone();
                var stopDistance = 0.5;

                if (startPosition.distanceTo(intersectPoint) < stopDistance + 0.5) {
                    console.log("Камера уже достаточно близко. Запускаем анимацию поворота.");

                    animateRotation(clickPoint); // Анимация поворота камеры
                    return; // Выход из функции, если движение не требуется
                }


                intersectPoint.y = cameraHeight + personHeight / 2; // Учитываем высоту "человека" и ставим центр капсулы
                if (isColliding(intersectPoint, true)) {
                    console.log("Целевая точка внутри BoxHelper. Ищем безопасную позицию.");
                    const safePosition = findSafePosition(intersectPoint);
                    if (safePosition) {
                        console.log("Найдена безопасная позиция:", safePosition);
                        moveToPosition(safePosition);
                        //animateRotation(clickPoint); 
                    } else {
                        console.log("Безопасная позиция не найдена.");
                        // intersectPoint.y = cameraHeight;
                        // Обработка ситуации, когда безопасная точка не найдена
                        animateRotation(clickPoint); // Анимация поворота камеры
                        return; // Выход из функции, если движение не требуется 
                    }
                } else {



                    moveToPosition(intersectPoint);
                }
            } else {
                console.log('Нет пересечений');
            }
        }

        function moveToPosition(targetPosition) {
            var duration = 1000; // Продолжительность анимации
            var startPosition = camera.position.clone(); // Начальная позиция камеры
            var stopDistance = 0.5; // Расстояние, на котором остановится камера           

            var startTime = performance.now(); // Время старта

            function animateMovement() {
                var elapsedTime = performance.now() - startTime; // Время, прошедшее с начала
                var t = elapsedTime / duration; // Нормализованное время для анимации

                // Линейная интерполяция позиции камеры
                if (t < 1) {
                    camera.position.lerpVectors(startPosition, targetPosition, t);

                    // Проверяем расстояние до целевой позиции
                    if (camera.position.distanceTo(targetPosition) > stopDistance) {
                        requestAnimationFrame(animateMovement); // Продолжаем анимацию
                    }
                } else {
                    // Если анимация завершена, но расстояние больше 0.5 метра, устанавливаем конечную позицию
                    if (camera.position.distanceTo(targetPosition) > stopDistance) {
                        camera.position.copy(targetPosition);
                        // camera.lookAt(targetPosition); // Устанавливаем направление взгляда
                    }
                }
            }

            animateMovement();
        }


        function animateRotation(targetPosition) {
            if (isAnimating) return; // Чтобы предотвратить повторный запуск анимации, если она уже идет

            isAnimating = true;

            var startQuaternion = camera.quaternion.clone(); // Начальная ориентация камеры
            var targetQuaternion = new THREE.Quaternion(); // Целевая ориентация камеры
            var duration = 1000; // Продолжительность анимации
            var startTime = performance.now();

            // Вычисляем целевой поворот для камеры
            camera.lookAt(targetPosition);
            targetQuaternion.copy(camera.quaternion);
            camera.quaternion.copy(startQuaternion); // Возвращаем начальную ориентацию

            function animate() {
                var elapsedTime = performance.now() - startTime;
                var t = Math.min(elapsedTime / duration, 1); // Нормализованное время для анимации (0 до 1)

                // Линейная интерполяция кватернионов
                camera.quaternion.slerpQuaternions(startQuaternion, targetQuaternion, t);

                if (t < 1) {
                    requestAnimationFrame(animate);
                } else {
                    camera.quaternion.copy(targetQuaternion); // Устанавливаем конечную ориентацию
                    isAnimating = false; // Завершаем анимацию
                    currentCameraQuaternion.copy(camera.quaternion); // Сохраняем новую ориентацию камеры
                    var cameraRotation = new THREE.Euler().setFromQuaternion(currentCameraQuaternion, 'YXZ');
                    yaw = cameraRotation.y;
                    pitch = cameraRotation.x;
                }
            }

            animate();
        }

        function onDocumentMouseMove(event) {
            if (isMouseDown && !isAnimating) {
                var deltaX = event.clientX - prevMouseX;
                var deltaY = event.clientY - prevMouseY;

                var sensitivity = 0.002;
                var maxDelta = 0.1;

                yaw += Math.max(-maxDelta, Math.min(maxDelta, deltaX * sensitivity));
                pitch += Math.max(-maxDelta, Math.min(maxDelta, deltaY * sensitivity));

                pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));

                let smoothedYaw = yaw;
                let smoothedPitch = pitch;
                let smoothingFactor = 0.1;

                smoothedYaw = THREE.MathUtils.lerp(smoothedYaw, yaw, smoothingFactor);
                smoothedPitch = THREE.MathUtils.lerp(smoothedPitch, pitch, smoothingFactor);


                var quaternion = new THREE.Quaternion();
                quaternion.setFromEuler(new THREE.Euler(smoothedPitch, smoothedYaw, 0, 'YXZ'));

                camera.quaternion.copy(quaternion);

                prevMouseX = event.clientX;
                prevMouseY = event.clientY;
            }
        }

        function countTriangles(scene) {
            let totalTriangles = 0;

            scene.traverse((object) => {
                //console.log(object.name);
                //console.log(object.type);
                if (object.isMesh) { // Проверяем, что объект является мешем
                    const geometry = object.geometry;

                    if (geometry.index !== null) {
                        // Считаем треугольники для геометрии с индексом
                        totalTriangles += geometry.index.count / 3;
                    } else if (geometry.attributes.position !== undefined) {
                        // Считаем треугольники для геометрии без индекса
                        totalTriangles += geometry.attributes.position.count / 3;
                    }
                }
            });

            console.log(`Общее количество треугольников: ${totalTriangles}`);
            return totalTriangles;
        }

        function onTouchEnd(event) {
            if (event.changedTouches.length === 1) {
                isMouseDown = false;
                container.classList.remove('cursor-clicking');

                var touchEndTime = performance.now();
                var timeDiff = touchEndTime - mouseDownTime;

                if (!mouseMoved && timeDiff < 200) {
                    onClick(event);
                }
            }
        }

        function onTouchStart(event) {
            if (event.touches.length === 1) {

                var touch = event.touches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                isMouseDown = true;
                mouseMoved = false;
                mouseDownTime = performance.now();
                container.classList.add('cursor-clicking');
                //event.preventDefault();
            }
        }

        function onTouchMove(event) {
            if (event.touches.length === 1 && isMouseDown) {

                var touch = event.touches[0];
                var deltaX = touch.clientX - touchStartX;
                var deltaY = touch.clientY - touchStartY;

                var sensitivity = 0.002;

                yaw += deltaX * sensitivity;
                pitch += deltaY * sensitivity;

                pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));

                var yawQuaternion = new THREE.Quaternion();
                yawQuaternion.setFromEuler(new THREE.Euler(0, yaw, 0, 'XYZ'));

                var pitchQuaternion = new THREE.Quaternion();
                pitchQuaternion.setFromEuler(new THREE.Euler(pitch, 0, 0, 'XYZ'));

                camera.quaternion.copy(yawQuaternion);
                camera.quaternion.multiply(pitchQuaternion);

                touchStartX = touch.clientX;
                touchStartY = touch.clientY;

                mouseMoved = true;
                event.preventDefault();
            }
        }


        document.getElementById('3d-viewer').addEventListener('mousemove', onMouseMove);
        document.getElementById('3d-viewer').addEventListener('mousedown', onMouseDown);
        document.addEventListener('mouseup', onMouseUp);
        document.addEventListener('mousemove', onDocumentMouseMove);
        document.getElementById('3d-viewer').addEventListener('touchstart', onTouchStart);
        document.getElementById('3d-viewer').addEventListener('touchmove', onTouchMove);
        document.addEventListener('touchend', onTouchEnd);

        window.addEventListener('resize', function () {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setPixelRatio(1);
            // var renderWidth = container.clientWidth ;
            //var renderHeight = container.clientHeight;
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.domElement.style.width = '100%';
            renderer.domElement.style.height = '100%';
            renderer.domElement.style.imageRendering = 'auto';
            var size = new THREE.Vector2();
            renderer.getSize(size);
            console.log('devicePixelRatio:', window.devicePixelRatio);
            console.log('Текущая ширина рендера:', size.width);
            console.log('Текущая высота рендера:', size.height);
        });

        function animate() {
            // console.log('Рендер кадра');

            stats.begin(); // Начало измерения производительности

            requestAnimationFrame(animate);
            updateCameraPosition();

            renderer.render(scene, camera);

            // composer.render();

            // Обновляем маркер камеры
            // updateCameraMarker();
            // Логика обновления LOD
            /*  lod.update = function () {
                       const distance = camera.position.distanceTo(lod.position); // Расстояние от камеры до LOD
                       const currentLevel = lod.levels.findIndex(level => distance >= level.distance);
           
                       console.log(`Текущее расстояние до LOD: ${distance.toFixed(2)}`);
                       console.log(`Текущий уровень LOD: ${currentLevel >= 0 ? currentLevel : "Хай-полигональная модель"}`);
                   };

              lod.update(); // Вызываем метод обновления LOD*/
            // Рендер сцены для карты (вид сверху)
            // mapRenderer.render(scene, mapCamera);
            stats.end(); // Конец измерения производительности
        }

        init();
        animate();
    </script>
</body>

</html>