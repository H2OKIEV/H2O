<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Viewer Babylon.js</title>
    <style>
        #3d-viewer {
            cursor: grab;
            position: relative;
            width: 100%;
            height: 80vh;
            overflow: hidden;
        }

        .cursor-pointer {
            cursor: pointer;
        }

        .cursor-clicking {
            cursor: grabbing;
        }
    </style>
</head>

<body>
    <canvas id="3d-viewer" style="width: 100%; height: 80vh;"></canvas>

    <label>
        Загрузить GLB
        <input type="file" id="fileInput" accept=".glb" />
    </label>

    <label>
        Загрузить HDRI
        <input type="file" id="hdriInput" accept=".hdr,.exr" />
    </label>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <script>

        // import * as BABYLON from 'https://cdn.jsdelivr.net/npm/babylonjs@6.18.0/index.min.js';
        // import 'https://cdn.jsdelivr.net/npm/babylonjs-loaders@6.18.0/index.min.js';

        // Инициализация сцены
        var canvas = document.getElementById("3d-viewer");
        var engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, antialiasing: true });
        var scene = new BABYLON.Scene(engine);

        const camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(-2, 1.5, 1), scene);
        camera.setTarget(new BABYLON.Vector3(-3, 1.5, 1)); // Точка, на которую смотрит камера
        camera.minZ = 0.1;
        // Устанавливаем радиус коллизий камеры
        camera.checkCollisions = true;
        camera.collisionsEnabled = true;
        camera.radius = 0.1;  // Радиус столкновения камеры

        // Включаем коллизии для объектов на сцене
        scene.collisionsEnabled = true;
        // Закрепляем управление на холсте
        camera.attachControl(canvas, true);

        // Ограничение высоты камеры
        scene.onBeforeRenderObservable.add(() => {
            if (camera.position.y < 1.5) {
                camera.position.y = 1.5; // Минимальная высота
            }
            if (camera.position.y > 1.5) {
                camera.position.y = 1.5; // Максимальная высота (фиксируем на уровне 1.5)
            }
        });

        const ssaoPipeline = new BABYLON.SSAO2RenderingPipeline("ssao", scene, {
            ssaoRatio: 0.5,       // Коэффициент разрешения SSAO
            blurRatio: 0.5        // Коэффициент разрешения размытия

        });

        ssaoPipeline.expensiveBlur = true;       // Более качественное размытие
        ssaoPipeline.samples = 16;              // Количество выборок для AO
        ssaoPipeline.maxZ = 100;                // Максимальная глубина AO

        // Привязка SSAO к камере
        scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline("ssao", camera);
        const fxaa = new BABYLON.FxaaPostProcess("fxaa", 1.0, camera);
        // Настройка параметров SSAO
        ssaoPipeline.radius = 2;                 // Радиус выборки AO
        ssaoPipeline.totalStrength = 1.5;       // Интенсивность AO
        ssaoPipeline.base = 0.5;

        // Включаем управление клавиатурой
        camera.keysUp.push(87);    // W - вперед
        camera.keysDown.push(83);  // S - назад
        camera.keysLeft.push(65);  // A - влево
        camera.keysRight.push(68); // D - вправо

        // Настраиваем скорость передвижения
        camera.speed = 0.1;

        // Добавление света
        var light2 = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene);
        light2.intensity = 0.7;


        // Создание света
        // const light = new BABYLON.DirectionalLight("light", new BABYLON.Vector3(-1, -2, -1), scene);
        //light.position = new BABYLON.Vector3(10, 10, 0);
        // Включение теней
        /*   light.shadowMinZ = 1;
           light.shadowMaxZ = 1000;
          const shadowGenerator = new BABYLON.ShadowGenerator(1024, light);*/

        // Создание пола, чтобы увидеть тени
        //const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 10, height: 10 }, scene);
        // ground.receiveShadows = true; // Пол также будет принимать тени
        // Загрузка HDRI текстуры по умолчанию
         const hdrTexture = new BABYLON.HDRCubeTexture("envMap.hdr", scene, 512);
 
         // Устанавливаем как карту окружения
         scene.environmentTexture = hdrTexture;
         scene.createDefaultSkybox(hdrTexture, true, 1000, 0.3); // Skybox
 
        // Загрузка GLB файла по умолчанию
        /*  BABYLON.SceneLoader.Append("./", "untitled.glb", scene, function (scene) {
              scene.createDefaultCameraOrLight(true, true, true); // Создаем стандартную камеру и свет, если их нет
          });*/


        // Добавление Bloom через DefaultRenderingPipeline
        const pipeline = new BABYLON.DefaultRenderingPipeline("defaultPipeline", true, scene, [camera]);
        pipeline.bloomEnabled = true;
        pipeline.bloomThreshold = 0.6;
        pipeline.bloomIntensity = 1.2;

        // GlowLayer для выделения светящихся объектов
        const glowLayer = new BABYLON.GlowLayer("glow", scene);
        glowLayer.intensity = 0.5;

        // Загрузка GLB модели
        BABYLON.SceneLoader.ImportMesh("", "./", "flat_1C1.glb", scene, (meshes) => {
            // Установка свойств для отбрасывания теней
            meshes.forEach(mesh => {
                mesh.receiveShadows = true; // Модель будет принимать тени
                mesh.castShadows = true; // Модель будет отбрасывать тени
                // Дополнительно: можно настроить материал, если требуется
            });

            scene.meshes.forEach((mesh) => {
                //mesh.checkCollisions = true;
            });
            // Настраиваем материалы после загрузки
            scene.meshes.forEach(mesh => {
                if (mesh.material) {
                    const material = mesh.material;

                    // Проверяем и добавляем свечение
                    if (!material.emissiveColor) {
                        material.emissiveColor = new BABYLON.Color3(1, 1, 0); // Желтое свечение
                    }

                    // Добавляем меш в GlowLayer
                    glowLayer.addIncludedOnlyMesh(mesh);
                }
            });
        });

        // Обработчик для загрузки GLB файла
        document.getElementById('fileInput').addEventListener('change', function (event) {
            var file = event.target.files[0];
            if (file) {
                var blobURL = URL.createObjectURL(file);

                // Загрузка через URL
                BABYLON.SceneLoader.Append("", blobURL, scene, function (scene) {
                    console.log("GLB файл загружен успешно.");
                }, null, function (scene, message, exception) {
                    console.error("Ошибка при загрузке GLB файла:", message, exception);
                });
            }
        });

        // Обработчик для загрузки HDRI
        document.getElementById('hdriInput').addEventListener('change', function (event) {
            var file = event.target.files[0];
            if (file) {
                var reader = new FileReader();
                reader.onload = function (e) {
                    // Очистка предыдущей текстуры, если необходимо
                    if (scene.environmentTexture) {
                        scene.environmentTexture.dispose();
                    }

                    // Загружаем HDRI текстуру
                    const newHdrTexture = new BABYLON.HDRCubeTexture(e.target.result, scene, 512);

                    // Применяем HDRI как окружающую среду
                    scene.createDefaultSkybox(newHdrTexture, true, true, 1);

                    // Обработка события завершения загрузки
                    newHdrTexture.onLoadObservable.add(() => {
                        console.log("HDRI текстура загружена успешно");
                    });

                    // Обработка ошибки загрузки
                    newHdrTexture.onErrorObservable.add(() => {
                        console.error("Ошибка загрузки HDRI текстуры");
                    });
                };
                reader.readAsArrayBuffer(file);
            }
        });

        // Цикл рендера
        engine.runRenderLoop(function () {
            scene.render();
        });

        // Изменение размера окна
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>

</html>